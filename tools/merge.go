package main

import (
	"encoding/json"
	"fmt"
	"io/fs"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

var template = `
// Code generated by type.sh. DO NOT EDIT.

package source

var BaseType = %s

var NetworkType = %s
`

type Version string

const  (
	V1139 = Version("v1.1.39")
)

func main() {
	// source
	sourceFiles,err:=filePathWorkDir(V1139,"source")
	if err != nil {
		panic(err)
	}
	sourceData,err:=getSourceFileData(sourceFiles)
	if err != nil {
		panic(err)
	}
	// network
	nwFiles,err:=filePathWorkDir(V1139,"network")
	if err != nil {
		panic(err)
	}
	nwData,err:=getNetworkFileData(nwFiles)
	if err != nil {
		panic(err)
	}
	types:=fmt.Sprintf(template,fmt.Sprintf("`%s`",sourceData),fmt.Sprintf("`%s`",nwData))
	pwd,err:=os.Getwd()
	if err != nil {
		panic(err)
	}
	pwdSplit:=strings.Split(pwd,"substrate-rpc-go")
	if len(pwdSplit)!=2 {
		fmt.Println("pwd is not equal substrate-rpc-go ,pwd=",pwd)
		return
	}

	writeToFile(fmt.Sprintf("%ssubstrate-rpc-go/source/base.go",pwdSplit[0]), types)
}

func filePathWorkDir(version Version,target string)([]string,error){
	gopath:=os.Getenv("GOPATH")
	fp:=fmt.Sprintf("%s/pkg/mod/github.com/itering/scale.go@%s/%s",gopath,version,target)
	var files []string
	err := filepath.Walk(fp, func(path string, info fs.FileInfo, err error) error {
		if info==nil {
			return err
		}
		if !info.IsDir() {
			files = append(files,path)
		}
		return nil
	})
	return files,err
}

func getSourceFileData(files []string)([]byte,error)  {
	source := make(map[string]interface{})
	for _,filePath := range files{
		if splitArr:=strings.Split(filePath,".");splitArr[len(splitArr)-1]=="json" {
			c,_:=ioutil.ReadFile(filePath)
			local := make(map[string]interface{})
			json.Unmarshal(c,&local)
			for key,value:=range local{
				source[key] = value
			}
		}
	}
	return json.Marshal(source)
}

func getNetworkFileData(files []string)([]byte,error){
	network:=make(map[string]map[string]interface{})
	for _,filePath:=range files{
		if splitArr:=strings.Split(filePath,".");splitArr[len(splitArr)-1]=="json" {
			source := make(map[string]interface{})

			fileNames:=strings.Split(splitArr[len(splitArr)-2],"/")
			fn:=fileNames[len(fileNames)-1]
			c,_:=ioutil.ReadFile(filePath)
			local := make(map[string]interface{})
			json.Unmarshal(c,&local)
			for key,value:=range local{
				source[key] = value
			}
			network[fn] = source
		}
	}
	return json.Marshal(network)
}

func writeToFile(target, content string) {
	fmt.Println("write file path: ",target)
	err := ioutil.WriteFile(target, []byte(content), 0644)
	if err != nil {
		panic(err)
	}
}